{"id":"../node_modules/@stablelib/xchacha20poly1305/lib/xchacha20poly1305.js","dependencies":[{"name":"C:\\Users\\Simon Palmer\\Documents\\Programming\\ETHDenver 2021\\furball-dapp\\node_modules\\@stablelib\\xchacha20poly1305\\lib\\xchacha20poly1305.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\Simon Palmer\\Documents\\Programming\\ETHDenver 2021\\furball-dapp\\node_modules\\@stablelib\\xchacha20poly1305\\xchacha20poly1305.ts","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\Simon Palmer\\Documents\\Programming\\ETHDenver 2021\\furball-dapp\\package.json","includedInParent":true,"mtime":1612734035267},{"name":"C:\\Users\\Simon Palmer\\Documents\\Programming\\ETHDenver 2021\\furball-dapp\\node_modules\\@stablelib\\xchacha20poly1305\\package.json","includedInParent":true,"mtime":1612644319468},{"name":"@stablelib/xchacha20","loc":{"line":5,"column":26},"parent":"C:\\Users\\Simon Palmer\\Documents\\Programming\\ETHDenver 2021\\furball-dapp\\node_modules\\@stablelib\\xchacha20poly1305\\lib\\xchacha20poly1305.js","resolved":"C:\\Users\\Simon Palmer\\Documents\\Programming\\ETHDenver 2021\\furball-dapp\\node_modules\\@stablelib\\xchacha20\\lib\\xchacha20.js"},{"name":"@stablelib/chacha20poly1305","loc":{"line":6,"column":33},"parent":"C:\\Users\\Simon Palmer\\Documents\\Programming\\ETHDenver 2021\\furball-dapp\\node_modules\\@stablelib\\xchacha20poly1305\\lib\\xchacha20poly1305.js","resolved":"C:\\Users\\Simon Palmer\\Documents\\Programming\\ETHDenver 2021\\furball-dapp\\node_modules\\@stablelib\\chacha20poly1305\\lib\\chacha20poly1305.js"},{"name":"@stablelib/wipe","loc":{"line":7,"column":21},"parent":"C:\\Users\\Simon Palmer\\Documents\\Programming\\ETHDenver 2021\\furball-dapp\\node_modules\\@stablelib\\xchacha20poly1305\\lib\\xchacha20poly1305.js","resolved":"C:\\Users\\Simon Palmer\\Documents\\Programming\\ETHDenver 2021\\furball-dapp\\node_modules\\@stablelib\\wipe\\lib\\wipe.js"}],"generated":{"js":"\"use strict\";\n// Copyright (C) 2019 Kyle Den Hartog\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar xchacha20_1 = require(\"@stablelib/xchacha20\");\nvar chacha20poly1305_1 = require(\"@stablelib/chacha20poly1305\");\nvar wipe_1 = require(\"@stablelib/wipe\");\nexports.KEY_LENGTH = 32;\nexports.NONCE_LENGTH = 24;\nexports.TAG_LENGTH = 16;\n/**\n * XChaCha20-Poly1305 Authenticated Encryption with Associated Data.\n *\n * Defined in draft-irtf-cfrg-xchacha-01.\n * See https://tools.ietf.org/html/draft-irtf-cfrg-xchacha-01\n */\nvar XChaCha20Poly1305 = /** @class */ (function () {\n    /**\n     * Creates a new instance with the given 32-byte key.\n     */\n    function XChaCha20Poly1305(key) {\n        this.nonceLength = exports.NONCE_LENGTH;\n        this.tagLength = exports.TAG_LENGTH;\n        if (key.length !== exports.KEY_LENGTH) {\n            throw new Error(\"ChaCha20Poly1305 needs 32-byte key\");\n        }\n        // Copy key.\n        this._key = new Uint8Array(key);\n    }\n    /**\n     * Encrypts and authenticates plaintext, authenticates associated data,\n     * and returns sealed ciphertext, which includes authentication tag.\n     *\n     * draft-irtf-cfrg-xchacha-01 defines a 24 byte nonce (192 bits) which\n     * uses the first 16 bytes of the nonce and the secret key with\n     * HChaCha to generate an initial subkey. The last 8 bytes of the nonce\n     * are then prefixed with 4 zero bytes and then provided with the subkey\n     * to the ChaCha20Poly1305 implementation.\n     *\n     * If dst is given (it must be the size of plaintext + the size of tag\n     * length) the result will be put into it. Dst and plaintext must not\n     * overlap.\n     */\n    XChaCha20Poly1305.prototype.seal = function (nonce, plaintext, associatedData, dst) {\n        if (nonce.length !== 24) {\n            throw new Error(\"XChaCha20Poly1305: incorrect nonce length\");\n        }\n        // Use HSalsa one-way function to transform first 16 bytes of\n        // 24-byte extended nonce and key into a new key for Salsa\n        // stream -- \"subkey\".\n        var subKey = xchacha20_1.hchacha(this._key, nonce.subarray(0, 16), new Uint8Array(32));\n        // Use last 8 bytes of 24-byte extended nonce as an actual nonce prefixed by 4 zero bytes,\n        // and a subkey derived in the previous step as key to encrypt.\n        var modifiedNonce = new Uint8Array(12);\n        modifiedNonce.set(nonce.subarray(16), 4);\n        var chaChaPoly = new chacha20poly1305_1.ChaCha20Poly1305(subKey);\n        var result = chaChaPoly.seal(modifiedNonce, plaintext, associatedData, dst);\n        wipe_1.wipe(subKey);\n        wipe_1.wipe(modifiedNonce);\n        chaChaPoly.clean();\n        return result;\n    };\n    /**\n     * Authenticates sealed ciphertext (which includes authentication tag) and\n     * associated data, decrypts ciphertext and returns decrypted plaintext.\n     *\n     * draft-irtf-cfrg-xchacha-01 defines a 24 byte nonce (192 bits) which\n     * then uses the first 16 bytes of the nonce and the secret key with\n     * Hchacha to generate an initial subkey. The last 8 bytes of the nonce\n     * are then prefixed with 4 zero bytes and then provided with the subkey\n     * to the chacha20poly1305 implementation.\n     *\n     * If authentication fails, it returns null.\n     *\n     * If dst is given (it must be the size of plaintext + the size of tag\n     * length) the result will be put into it. Dst and plaintext must not\n     * overlap.\n     */\n    XChaCha20Poly1305.prototype.open = function (nonce, sealed, associatedData, dst) {\n        if (nonce.length !== 24) {\n            throw new Error(\"XChaCha20Poly1305: incorrect nonce length\");\n        }\n        // Sealed ciphertext should at least contain tag.\n        if (sealed.length < this.tagLength) {\n            // TODO(dchest): should we throw here instead?\n            return null;\n        }\n        /**\n        * Generate subKey by using HChaCha20 function as defined\n        * in section 2 step 1 of draft-irtf-cfrg-xchacha-01\n        */\n        var subKey = xchacha20_1.hchacha(this._key, nonce.subarray(0, 16), new Uint8Array(32));\n        /**\n        * Generate Nonce as defined - remaining 8 bytes of the nonce prefixed with\n        * 4 zero bytes\n        */\n        var modifiedNonce = new Uint8Array(12);\n        modifiedNonce.set(nonce.subarray(16), 4);\n        /**\n         * Authenticate and decrypt by calling into chacha20poly1305.\n         */\n        var chaChaPoly = new chacha20poly1305_1.ChaCha20Poly1305(subKey);\n        var result = chaChaPoly.open(modifiedNonce, sealed, associatedData, dst);\n        wipe_1.wipe(subKey);\n        wipe_1.wipe(modifiedNonce);\n        chaChaPoly.clean();\n        return result;\n    };\n    XChaCha20Poly1305.prototype.clean = function () {\n        wipe_1.wipe(this._key);\n        return this;\n    };\n    return XChaCha20Poly1305;\n}());\nexports.XChaCha20Poly1305 = XChaCha20Poly1305;\n"},"sourceMaps":{"js":{"version":3,"file":"xchacha20poly1305.js","sourceRoot":"","sources":["../xchacha20poly1305.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (C) 2019 Kyle Den Hartog\n// MIT License. See LICENSE file for details.\n\n/**\n * Package xchacha20poly1305 implements XChaCha20-Poly1305 AEAD.\n */\n\nimport { AEAD } from \"@stablelib/aead\";\nimport { hchacha } from \"@stablelib/xchacha20\";\nimport { ChaCha20Poly1305 } from \"@stablelib/chacha20poly1305\";\nimport { wipe } from \"@stablelib/wipe\";\n\nexport const KEY_LENGTH = 32;\nexport const NONCE_LENGTH = 24;\nexport const TAG_LENGTH = 16;\n\n/**\n * XChaCha20-Poly1305 Authenticated Encryption with Associated Data.\n *\n * Defined in draft-irtf-cfrg-xchacha-01.\n * See https://tools.ietf.org/html/draft-irtf-cfrg-xchacha-01\n */\nexport class XChaCha20Poly1305 implements AEAD {\n  readonly nonceLength = NONCE_LENGTH;\n  readonly tagLength = TAG_LENGTH;\n\n  private _key: Uint8Array;\n\n  /**\n   * Creates a new instance with the given 32-byte key.\n   */\n  constructor(key: Uint8Array) {\n    if (key.length !== KEY_LENGTH) {\n      throw new Error(\"ChaCha20Poly1305 needs 32-byte key\");\n    }\n    // Copy key.\n    this._key = new Uint8Array(key);\n  }\n\n  /**\n   * Encrypts and authenticates plaintext, authenticates associated data,\n   * and returns sealed ciphertext, which includes authentication tag.\n   *\n   * draft-irtf-cfrg-xchacha-01 defines a 24 byte nonce (192 bits) which\n   * uses the first 16 bytes of the nonce and the secret key with\n   * HChaCha to generate an initial subkey. The last 8 bytes of the nonce\n   * are then prefixed with 4 zero bytes and then provided with the subkey\n   * to the ChaCha20Poly1305 implementation.\n   *\n   * If dst is given (it must be the size of plaintext + the size of tag\n   * length) the result will be put into it. Dst and plaintext must not\n   * overlap.\n   */\n  seal(\n    nonce: Uint8Array,\n    plaintext: Uint8Array,\n    associatedData?: Uint8Array,\n    dst?: Uint8Array\n  ): Uint8Array {\n    if (nonce.length !== 24) {\n      throw new Error(\"XChaCha20Poly1305: incorrect nonce length\");\n    }\n    // Use HSalsa one-way function to transform first 16 bytes of\n    // 24-byte extended nonce and key into a new key for Salsa\n    // stream -- \"subkey\".\n    const subKey = hchacha(this._key, nonce.subarray(0, 16), new Uint8Array(32));\n\n\n    // Use last 8 bytes of 24-byte extended nonce as an actual nonce prefixed by 4 zero bytes,\n    // and a subkey derived in the previous step as key to encrypt.\n    const modifiedNonce = new Uint8Array(12);\n    modifiedNonce.set(nonce.subarray(16), 4);\n\n    const chaChaPoly = new ChaCha20Poly1305(subKey);\n    const result = chaChaPoly.seal(modifiedNonce, plaintext, associatedData, dst);\n    wipe(subKey);\n    wipe(modifiedNonce);\n    chaChaPoly.clean();\n    return result;\n  }\n\n  /**\n   * Authenticates sealed ciphertext (which includes authentication tag) and\n   * associated data, decrypts ciphertext and returns decrypted plaintext.\n   *\n   * draft-irtf-cfrg-xchacha-01 defines a 24 byte nonce (192 bits) which\n   * then uses the first 16 bytes of the nonce and the secret key with\n   * Hchacha to generate an initial subkey. The last 8 bytes of the nonce\n   * are then prefixed with 4 zero bytes and then provided with the subkey\n   * to the chacha20poly1305 implementation.\n   *\n   * If authentication fails, it returns null.\n   *\n   * If dst is given (it must be the size of plaintext + the size of tag\n   * length) the result will be put into it. Dst and plaintext must not\n   * overlap.\n   */\n  open(\n    nonce: Uint8Array,\n    sealed: Uint8Array,\n    associatedData?: Uint8Array,\n    dst?: Uint8Array\n  ): Uint8Array | null {\n    if (nonce.length !== 24) {\n      throw new Error(\"XChaCha20Poly1305: incorrect nonce length\");\n    }\n\n    // Sealed ciphertext should at least contain tag.\n    if (sealed.length < this.tagLength) {\n      // TODO(dchest): should we throw here instead?\n      return null;\n    }\n\n    /**\n    * Generate subKey by using HChaCha20 function as defined\n    * in section 2 step 1 of draft-irtf-cfrg-xchacha-01\n    */\n    const subKey = hchacha(\n      this._key,\n      nonce.subarray(0, 16),\n      new Uint8Array(32)\n    );\n\n    /**\n    * Generate Nonce as defined - remaining 8 bytes of the nonce prefixed with\n    * 4 zero bytes\n    */\n    const modifiedNonce = new Uint8Array(12);\n    modifiedNonce.set(nonce.subarray(16), 4);\n\n    /**\n     * Authenticate and decrypt by calling into chacha20poly1305.\n     */\n    const chaChaPoly = new ChaCha20Poly1305(subKey);\n    const result = chaChaPoly.open(modifiedNonce, sealed, associatedData, dst);\n    wipe(subKey);\n    wipe(modifiedNonce);\n    chaChaPoly.clean();\n    return result;\n  }\n\n  clean(): this {\n    wipe(this._key);\n    return this;\n  }\n}\n"]}},"error":null,"hash":"f17c61d654318096bf734bf6c33039d0","cacheData":{"env":{}}}